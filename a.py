import sys
import copy
import subprocess

count = 0

def parse_file(filepath):
    	# read the layout file to the board array
    board = []

    fin = open(filepath)
	file_content = fin.readline().strip().split('\n')
	#print file_content	
	board_config = file_content[0].split(' ')
	row = int(board_config[0])
	col = int(board_config[1])
	#print "Row : Col   " + str(row) + "  " + str(col)	
	board = [[0 for x in range(col)] for x in range(row)]

	for i in range(row):
		line = fin.readline().strip().split('\n')
		nos = line[0].split(',')
		#print line
		for j in range(col):
			token = nos[j]
			if token == 'X':
				token = -1
			token = int(token)
			#print token
			#print i,j
			board[i][j] = token
	fin.close()
    return board,row,col

def find_all_clauses(input_array,
		     input_len,
		     combi_len,
		     indi_tup,
		     ans_index,
		     next_start,
		     clause_tup):
	global count
	for iter in range(next_start,input_len+1):
		#print "Combi len " + str(combi_len)
		if combi_len <= 0:
			clause_tup.append(copy.copy(indi_tup))	
			count = count + 1
			return
	
		#print "Ans index " + str(ans_index) + "Iter " + str(iter)	
		indi_tup[ans_index] = input_array[iter]
		find_all_clauses(input_array,
				 input_len,
				 combi_len-1,
				 indi_tup,
				 ans_index + 1,
				 iter + 1,
				 clause_tup)

def find_cell_no(i, j, row, col):
	return i*col + j + 1

def find_adjacent_cells(board, i, j, row, col):
	output = []	

	if i >= 1 and j >= 1:
		output.append(find_cell_no(i-1,j-1,row,col))
	if i >= 1:
		output.append(find_cell_no(i-1,j,row,col))
	if i >= 1 and j < (col - 1):
		output.append(find_cell_no(i-1,j+1,row,col))
	if j < (col - 1):
		output.append(find_cell_no(i,j+1,row,col))
	if i < (row - 1) and j < (col - 1):
		output.append(find_cell_no(i+1,j+1,row,col))
	if i < (row - 1):
		output.append(find_cell_no(i+1,j,row,col))
	if i < (row - 1) and j >= 1:
		output.append(find_cell_no(i+1,j-1,row,col))
	if j >= 1:
		output.append(find_cell_no(i,j-1,row,col))

	return output

def convert2CNF(board, row, col, output):
    # interpret the number constraints
	global count
	count_clause = 0
    fout = open(output, 'w')
   	 
	ftemp = open("temp", 'w')
	for i in range(row):
		for j in range(col):
			if board[i][j] != -1:
				first_adjacent_cells = find_adjacent_cells(board, i ,j, 
								row, col)
				count_adj = len(first_adjacent_cells)
				if ((board[i][j] > count_adj) or (board[i][j] < -1)):
					print ("Invalid board at postion Row: " + str(i) + " Col: " + str(j) + " !!!")
					sys.exit(1)

				first_adjacent_cells.append(0)
				#input_array = [0,1,2,3,4,0]
				#print "Adjacent cells = " + str(first_adjacent_cells)
				#print "Count = " + str(count_adj)
				#sys.exit(1);

				indi_tup = []
				for k in range(board[i][j] + 1):
					indi_tup.append(0);
				#print indi_tup
 				first_tup = []
				count = 0	
				find_all_clauses(first_adjacent_cells,count_adj,board[i][j]+1,indi_tup,0,0,first_tup)
				#print "Clause tuple " + str(first_tup)
				#print "Count " + str(count)
				count_clause = count_clause + count
			
				for k in range(len(first_tup)):
					for l in range(board[i][j] + 1):
						ftemp.write(str(-1*first_tup[k][l]) + " ")
					ftemp.write("0\n")
				#sys.exit(1)

				indi_tup = []
                                for k in range(count_adj - board[i][j] + 1):
                                        indi_tup.append(0);
                                #print indi_tup
				count = 0
				second_tup = []	
				find_all_clauses(first_adjacent_cells,count_adj,count_adj-board[i][j]+1,indi_tup,0,0,second_tup)
				#print "Second clause tuple " + str(second_tup)
				#print "Second Count " + str(count)
				count_clause = count_clause + count

                                for k in range(len(second_tup)):
                                        for l in range(count_adj-board[i][j] + 1):
                                                ftemp.write(str(second_tup[k][l]) + " ")
                                        ftemp.write("0\n")
				#print "Count clause = " + str(count_clause)
				#sys.exit(1)
			else:
				ftemp.write(str(find_cell_no(i,j,row,col)) + " 0\n")
				count_clause = count_clause + 1
    	ftemp.close()

        fout.write("c This file is generated by python program in CNF form for SAT evaluation\n")
        fout.write("p cnf " + str(row*col) + " " + str(count_clause) + "\n")

	fclause = open("temp", 'r')
	fout.write(fclause.read())
	fclause.close()
	fout.close()
	subprocess.call(["rm","temp"])
	subprocess.call(["/home/neeraj/Artificial_Intelligence/minisat/core/minisat","cnf","SAT_OUTPUT"])
	print "The status of variables after SAT evaluation is:"
	subprocess.call(["cat","SAT_OUTPUT"])
	subprocess.call(["rm","SAT_OUTPUT"])


if __name__ == '__main__':
    	if len(sys.argv) < 3:
        	print 'Layout or output file not specified.'
        	exit(-1)
    	board,row,col = parse_file(sys.argv[1])
	#print "Row : Col   " + str(row) + "  " + str(col)
	#print "Input array is : " + str(board)
    	convert2CNF(board, row, col, sys.argv[2])